<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>SxmAbstractAnimator.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">jsxm-maven-plugin</a> &gt; <a href="index.html" class="el_package">org.jsxm.maven.plugin.jsxmtool.animation.core</a> &gt; <span class="el_source">SxmAbstractAnimator.java</span></div><h1>SxmAbstractAnimator.java</h1><pre class="source lang-java linenums">/**
 * JSXM Maven PLugin CONFIDENTIAL
 * 
 *  __________________
 * 
 * Unpublished Copyright Â© 2012-2013 Konstantinos Margaritis, 
 * All Rights Reserved.
 * 
 * NOTICE:  All information contained herein is, and remains the property of Konstantinos Margaritis . 
 *
 * The intellectual and technical concepts contained herein are proprietary to the owner
 * Konstantinos Margaritis and may be covered by U.S and Foreign Patents, patents in process, 
 * and are protected by trade secret or copyright law. Dissemination of this information or 
 * reproduction of this material is strictly forbidden unless prior written permission is
 * obtained from Konstantinos Margaritis. Access to the source code contained herein is hereby 
 * forbidden to anyone except the owner.Confidentiality and Non-disclosure agreements 
 * explicitly covering such access.
 *
 * The copyright notice above does not evidence any actual or intended publication 
 * or disclosure  of  this source code, which includes information that is confidential 
 * and/or proprietary, and is a trade secret, of  Konstantinos Margaritis. ANY REPRODUCTION, 
 * MODIFICATION, DISTRIBUTION, PUBLIC  PERFORMANCE, OR PUBLIC DISPLAY OF OR THROUGH USE  OF 
 * THIS  SOURCE CODE  WITHOUT  THE EXPRESS WRITTEN CONSENT OF Konstantinos Margaritis IS STRICTLY PROHIBITED, 
 * AND IN VIOLATION OF APPLICABLE LAWS AND INTERNATIONAL TREATIES.  THE RECEIPT OR POSSESSION OF  
 * THIS SOURCE CODE AND/OR RELATED INFORMATION DOES NOT CONVEY OR IMPLY ANY RIGHTS  
 * TO REPRODUCE, DISCLOSE OR DISTRIBUTE ITS CONTENTS, OR TO MANUFACTURE, USE, OR SELL 
 * ANYTHING THAT IT  MAY DESCRIBE, IN WHOLE OR IN PART.  
 * 
 */
package org.jsxm.maven.plugin.jsxmtool.animation.core;

import java.io.BufferedReader;
import java.io.ByteArrayInputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.InputStreamReader;
import java.io.UnsupportedEncodingException;
import java.nio.charset.Charset;
import java.util.Arrays;
import java.util.Collection;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Set;
import java.util.StringTokenizer;

import javax.xml.bind.DatatypeConverter;

import org.jdom.Document;
import org.jdom.Element;
import org.jdom.output.Format;
import org.jdom.output.XMLOutputter;
import org.jsxm.jsxmcore.core.AbstractDefsxmFactory;
import org.jsxm.jsxmcore.core.Function;
import org.jsxm.jsxmcore.core.Input;
import org.jsxm.jsxmcore.core.Output;
import org.jsxm.jsxmcore.core.SXM;
import org.jsxm.jsxmcore.exceptions.DefinitionNotFoundException;
import org.jsxm.jsxmcore.exceptions.NullSXMValueException;
import org.jsxm.jsxmcore.loggingHelpers.AnimationLogger;
import org.jsxm.jsxmcore.runtimeexceptions.AliasSxmNotFoundException;
import org.jsxm.jsxmcore.runtimeexceptions.XSDTypeAdapterMarshallingException;
import org.jsxm.jsxmcore.runtimeexceptions.XSDTypeAdapterUnMarshallingException;
import org.jsxm.jsxmcore.types.Sxm;
import org.jsxm.jsxmcore.util.Various;
import org.jsxm.maven.plugin.jsxmtool.runtimeexceptions.EmptyBufferedReaderStringException;
import org.jsxm.maven.plugin.jsxmtool.utilities.SxmFileUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * @author Konstantinos Margaritis
 * 
 */
<span class="fc" id="L76">public abstract class SxmAbstractAnimator {</span>
    
<span class="fc" id="L78">    private final Logger logger = (Logger) LoggerFactory.getLogger(this.getClass());</span>
    private static final String DEBUG_SEPERATOR = &quot;===================================&quot;;
    private SXM fsm;
    private List&lt;String&gt; inputNames;
    private Element inputElement;
    private Output fsmCurrentOutput;
<span class="fc" id="L84">    private boolean txtInput=false;</span>
    private static final String ENCODING=&quot;UTF-8&quot;;
    
    /**
     * 
     * Providing the option -console the method returns a BufferedReader created
     * with System.in InputStream. Str is not used in case option is console.
     * 
     * @param str
     * @param option
     * @return
     * @throws UnsupportedEncodingException
     */
    protected BufferedReader animationInputSource(String str, String option,String animationDirectory) throws UnsupportedEncodingException {
<span class="fc" id="L98">        BufferedReader buffReader = null;</span>
<span class="fc" id="L99">        logger.debug(&quot;Printing the txtInput boolean: {}&quot;,txtInput);</span>
<span class="fc bfc" id="L100" title="All 2 branches covered.">        if(!txtInput){</span>
<span class="pc bpc" id="L101" title="1 of 2 branches missed.">            if (option.equals(&quot;console&quot;)) {</span>
<span class="fc" id="L102">                buffReader = new BufferedReader(new InputStreamReader(System.in, Charset.forName(ENCODING)));</span>
<span class="nc bnc" id="L103" title="All 2 branches missed.">            } else if (option.equals(&quot;gui&quot;)) {</span>
<span class="nc bnc" id="L104" title="All 2 branches missed.">                if (!str.equals(&quot;&quot;)) {</span>
<span class="nc" id="L105">                    buffReader = new BufferedReader(new InputStreamReader(new ByteArrayInputStream(str.getBytes(Charset</span>
                            .forName(&quot;ENCODING&quot;))), Charset.forName(ENCODING)));
                } else {
<span class="nc" id="L108">                    throw new EmptyBufferedReaderStringException(&quot;\nString provided to BufferedReader is empty&quot;);</span>
                }
            }
        }else{
<span class="fc" id="L112">            logger.debug(&quot;Reading inputs from: &quot;+animationDirectory+&quot;input.txt&quot;);</span>
            try {
<span class="fc" id="L114">                File input = new File(animationDirectory+&quot;input.txt&quot;);</span>
<span class="fc" id="L115">                buffReader = new BufferedReader( new InputStreamReader(new FileInputStream(input), ENCODING));</span>
<span class="nc" id="L116">            } catch (FileNotFoundException e) {</span>
<span class="nc" id="L117">                logger.error(&quot;FileNotFoundException : &quot;, e);</span>
<span class="fc" id="L118">            }   </span>
        }
<span class="fc" id="L120">        return buffReader;</span>
    }
    
    /**
     * Instantiate sxm.
     * 
     * @param className
     *            the class name
     * @param animationDirectory
     *            the animation directory
     * @param specificationDirectory
     *            the specification directory
     */
    protected void instantiateSXM(String className, String animationDirectory, String specificationDirectory) {
<span class="fc" id="L134">        AbstractDefsxmFactory.setDeffilePath(specificationDirectory);</span>
<span class="fc" id="L135">        AnimationLogger.getInstance().setAnimating(true);</span>
<span class="fc" id="L136">        final String specName = &quot;org.jsxm.jsxmcore.types.&quot; + className + &quot;SXM&quot;;</span>
<span class="fc" id="L137">        fsm = null;</span>
        try {
<span class="fc" id="L139">            fsm = (SXM) Various.getInstance().loadClass(specName).newInstance();</span>
<span class="nc" id="L140">        } catch (InstantiationException e) {</span>
<span class="nc" id="L141">            logger.error(&quot;InstantiationException : &quot;, e);</span>
<span class="nc" id="L142">        } catch (IllegalAccessException e) {</span>
<span class="nc" id="L143">            logger.error(&quot;IllegalAccessException : &quot;, e);</span>
<span class="pc" id="L144">        }</span>
<span class="fc" id="L145">    }</span>
    
    /**
     * Save.
     * 
     * @param doc
     *            the doc
     * @param xmlOutput
     *            the xml output
     * @param className
     *            the class name
     * @param animationDirectory
     *            the animation directory
     */
    protected void save(Document doc, XMLOutputter xmlOutput, String className, String animationDirectory) {
<span class="fc" id="L160">        xmlOutput.setFormat(Format.getPrettyFormat());</span>
<span class="fc" id="L161">        logger.debug(&quot;Animation Directory: &quot; + animationDirectory);</span>
<span class="fc" id="L162">        logger.debug(&quot;Class Name: &quot; + className);</span>
<span class="fc" id="L163">        logger.debug(&quot;Input_xml: &quot; + animationDirectory + className + &quot;_input.xml&quot;);</span>
<span class="fc" id="L164">        SxmFileUtils.writeXMLToFile(xmlOutput, doc, animationDirectory + className + &quot;_input.xml&quot;);</span>
<span class="fc" id="L165">    }</span>
    
    /**
     * Prepare step.
     * 
     * @param str
     *            the str
     * @param rootElement
     *            the root element
     * @return true, if successful
     */
    protected boolean prepareStep(String str, Element rootElement) {
        // TODO need a way to provide strings with spaces like 'Dimitris
        // Dranidis'
        
        // TODO Make a method about the elements and tokenizer.Try to create a
        // tokenizer that will accept spaces.
<span class="fc" id="L182">        fsmCurrentOutput = null;</span>
<span class="fc" id="L183">        StringTokenizer st = new StringTokenizer(str, &quot; (),\&quot;&quot;);</span>
<span class="fc" id="L184">        Input input = null;</span>
<span class="fc" id="L185">        String method = st.nextToken();</span>
<span class="fc" id="L186">        input = addInput(method, st, rootElement);</span>
<span class="fc bfc" id="L187" title="All 2 branches covered.">        if (input == null) {</span>
<span class="fc" id="L188">            printError(method + &quot; does not belong to the inputs.  .i. lists available inputs.&quot;);</span>
<span class="fc" id="L189">            return true;</span>
        }
<span class="pc bpc" id="L191" title="1 of 2 branches missed.">        if (st.countTokens() != input.getArgs().length) {</span>
<span class="nc" id="L192">            printError(&quot;Input &quot; + method + &quot; requires &quot; + input.getArgs().length</span>
                    + &quot; arguments.  .i. lists available inputs.&quot;);
<span class="nc" id="L194">            return true;</span>
        }
<span class="fc bfc" id="L196" title="All 2 branches covered.">        if (addArgument(input, st)) {</span>
<span class="fc" id="L197">            return true;</span>
        }
<span class="fc" id="L199">        animateStep(input);</span>
<span class="fc" id="L200">        return false;</span>
    }
    
    /**
     * Check iput arg.
     * 
     * @param input
     *            the input
     * @param type
     *            the type
     * @param argument
     *            the argument
     * @return true, if successful
     */
    private boolean checkIputArg(Input input, String type, String argument) {
<span class="fc" id="L215">        String errorMessage = &quot;The argument provided for &quot; + input.toString() + &quot; must a be a number&quot;;</span>
<span class="fc bfc" id="L216" title="All 2 branches covered.">        if (type.equals(&quot;xs:int&quot;)) {</span>
            try {
<span class="fc" id="L218">                Integer.parseInt(argument);</span>
<span class="nc" id="L219">            } catch (NumberFormatException e) {</span>
<span class="nc" id="L220">                printError(errorMessage);</span>
<span class="nc" id="L221">                return false;</span>
<span class="fc" id="L222">            }</span>
<span class="pc bpc" id="L223" title="1 of 2 branches missed.">        } else if (type.equals(&quot;xs:boolean&quot;)) {</span>
            try {
<span class="nc" id="L225">                Boolean.parseBoolean(argument);</span>
<span class="nc" id="L226">            } catch (NumberFormatException e) {</span>
<span class="nc" id="L227">                printError(errorMessage);</span>
<span class="nc" id="L228">                return false;</span>
<span class="nc" id="L229">            }</span>
<span class="pc bpc" id="L230" title="1 of 2 branches missed.">        } else if (type.equals(&quot;xs:decimal&quot;)) {</span>
            try {
<span class="nc" id="L232">                DatatypeConverter.parseDecimal(argument);</span>
<span class="nc" id="L233">            } catch (NumberFormatException e) {</span>
<span class="nc" id="L234">                printError(errorMessage);</span>
<span class="nc" id="L235">                return false;</span>
<span class="nc" id="L236">            }</span>
<span class="pc bpc" id="L237" title="1 of 2 branches missed.">        } else if (type.equals(&quot;xs:double&quot;)) {</span>
            try {
<span class="nc" id="L239">                Double.parseDouble(argument);</span>
<span class="nc" id="L240">            } catch (NumberFormatException e) {</span>
<span class="nc" id="L241">                printError(errorMessage);</span>
<span class="nc" id="L242">                return false;</span>
<span class="nc" id="L243">            }</span>
        }
<span class="fc" id="L245">        return true;</span>
    }
    
    /**
     * Adds the input.
     * 
     * @param input
     *            the input
     * @param method
     *            the method
     * @param st
     *            the st
     * @param rootElement
     *            the root element
     * @return the input
     */
    protected Input addInput(String method, StringTokenizer st, Element rootElement) {
<span class="fc" id="L262">        Input input = null;</span>
<span class="fc" id="L263">        inputNames = new LinkedList&lt;String&gt;();</span>
<span class="fc" id="L264">        inputElement = null;</span>
<span class="fc" id="L265">        Element callElement = null;</span>
<span class="fc" id="L266">        Collection&lt;Function&gt; functions = fsm.getFunctions();</span>
<span class="fc bfc" id="L267" title="All 2 branches covered.">        for (Function function : functions) {</span>
<span class="fc" id="L268">            input = function.getInput();</span>
<span class="fc bfc" id="L269" title="All 2 branches covered.">            if (input.getMethod().equals(method)) {</span>
<span class="pc bpc" id="L270" title="1 of 2 branches missed.">                if (st.countTokens() == input.getArgs().length) {</span>
<span class="fc" id="L271">                    callElement = new Element(&quot;call&quot;, Various.getInstance().getNameSpace());</span>
<span class="fc" id="L272">                    inputElement = new Element(&quot;input&quot;, Various.getInstance().getNameSpace());</span>
<span class="fc" id="L273">                    rootElement.addContent(callElement);</span>
<span class="fc" id="L274">                    callElement.addContent(inputElement);</span>
<span class="fc" id="L275">                    inputElement.setAttribute(&quot;name&quot;, input.getMethod());</span>
<span class="fc" id="L276">                    inputNames = Arrays.asList(input.getArgNames());</span>
                }
                break;
            } else {
<span class="fc" id="L280">                input = null;</span>
            }
<span class="fc" id="L282">        }</span>
<span class="fc" id="L283">        return input;</span>
    }
    
    /**
     * Gets the inputs.
     * 
     * @return the inputs
     */
    public Set&lt;String&gt; getInputs() {
<span class="fc" id="L292">        Collection&lt;Function&gt; functions = getFsm().getFunctions();</span>
<span class="fc" id="L293">        HashSet&lt;String&gt; signatures = new HashSet&lt;String&gt;();</span>
<span class="fc bfc" id="L294" title="All 2 branches covered.">        for (Function function : functions) {</span>
<span class="fc" id="L295">            Input input = function.getInput();</span>
<span class="fc" id="L296">            signatures.add(input.signature());</span>
<span class="fc" id="L297">        }</span>
<span class="fc" id="L298">        return signatures;</span>
    }
    
    /**
     * Adds the argument.
     * 
     * @param input
     *            the input
     * @param st
     *            the st
     * @return true, if successful
     */
    protected boolean addArgument(Input input, StringTokenizer st) {
<span class="fc" id="L311">        String temp = &quot;&quot;;</span>
        try {
<span class="fc bfc" id="L313" title="All 2 branches covered.">            for (int i = 0; i &lt; input.getArgs().length; i++) {</span>
<span class="fc" id="L314">                temp = st.nextToken();</span>
<span class="fc" id="L315">                boolean validArg = checkIputArg(input, input.getArg(i).getTypeName(), temp);</span>
<span class="pc bpc" id="L316" title="1 of 2 branches missed.">                if (validArg) {</span>
<span class="fc" id="L317">                    input.setArg(i, temp);</span>
<span class="pc bpc" id="L318" title="1 of 2 branches missed.">                    if (input.getArg(i).getTypeName() != null) {</span>
<span class="fc" id="L319">                        Element inputName = new Element(inputNames.get(i), Various.getInstance().getNameSpace());</span>
<span class="fc" id="L320">                        inputElement.addContent(inputName);</span>
<span class="fc" id="L321">                        inputName.setAttribute(&quot;type&quot;, input.getArg(i).getTypeName()).setText(temp);</span>
                    }
<span class="fc" id="L323">                    printInfo(&quot;Input argument: &quot; + Arrays.toString(input.getArgNames()));</span>
<span class="fc" id="L324">                    printInfo(&quot;Type: &quot; + input.getArg(i).getTypeName() + &quot; value :&quot; + input.getArg(i).getValue());</span>
                } else {
<span class="nc" id="L326">                    return true;</span>
                }
            }
<span class="nc" id="L329">        } catch (XSDTypeAdapterUnMarshallingException e) {</span>
<span class="nc" id="L330">            printError(&quot;Enable debug for full stacktrace. JAXB exception when unmarshaling XSDType: for &quot;,</span>
                    input.toString());
<span class="nc" id="L332">            logger.debug(&quot;XSDTypeAdapterUnMarshallingException exception &quot;, e);</span>
<span class="nc" id="L333">            return true;</span>
<span class="nc" id="L334">        } catch (XSDTypeAdapterMarshallingException e) {</span>
<span class="nc" id="L335">            printError(&quot;Enable debug for full stacktrace. JAXB exception when marshaling XSDType: for &quot;,</span>
                    input.toString());
<span class="nc" id="L337">            logger.debug(&quot;XSDTypeAdapterMarshallingException &quot;, e);</span>
<span class="nc" id="L338">            return true;</span>
<span class="nc" id="L339">        } catch (NullSXMValueException e) {</span>
<span class="nc" id="L340">            logger.error(&quot;NullSXMValueException : &quot;, e);</span>
<span class="nc" id="L341">            return true;</span>
<span class="fc" id="L342">        } catch (DefinitionNotFoundException e) {</span>
<span class="fc" id="L343">            logger.debug(DEBUG_SEPERATOR);</span>
<span class="fc" id="L344">            logger.debug(&quot;Debug stacktrace for animation&quot;);</span>
<span class="fc" id="L345">            logger.debug(&quot;DefinitionNotFoundException : &quot;, e);</span>
<span class="fc" id="L346">            logger.debug(&quot;End of Debug stacktrace for animation&quot;);</span>
<span class="fc" id="L347">            logger.debug(DEBUG_SEPERATOR);</span>
<span class="fc" id="L348">            printError(&quot;No definition &quot; + Sxm.DEFSXM + &quot; found for &quot; + temp);</span>
<span class="fc" id="L349">            return true;</span>
<span class="fc" id="L350">        } catch (AliasSxmNotFoundException e) {</span>
<span class="fc" id="L351">            logger.debug(DEBUG_SEPERATOR);</span>
<span class="fc" id="L352">            logger.debug(&quot;Debug stacktrace for animation&quot;);</span>
<span class="fc" id="L353">            logger.debug(&quot;AliasSxmNotFoundException : &quot;, e);</span>
<span class="fc" id="L354">            logger.debug(&quot;End of Debug stacktrace for animation&quot;);</span>
<span class="fc" id="L355">            logger.debug(DEBUG_SEPERATOR);</span>
<span class="fc" id="L356">            return true;</span>
<span class="fc" id="L357">        }</span>
<span class="fc" id="L358">        return false;</span>
    }
    
    /**
     * Animate step.
     * 
     * @param input
     *            the input
     */
    protected void animateStep(Input input) {
<span class="fc" id="L368">        Output response = null;</span>
<span class="fc" id="L369">        response = fsm.animateStep(input, SXM.CONTINUE_ON_ERROR);</span>
<span class="pc bpc" id="L370" title="1 of 2 branches missed.">        if (response != null) {</span>
<span class="fc" id="L371">            printInfo(&quot;Output : &quot; + response);</span>
<span class="fc" id="L372">            this.fsmCurrentOutput = response;</span>
<span class="fc" id="L373">            printSeparator(&quot;-&quot;);</span>
        }
<span class="fc" id="L375">    }</span>
    
    /**
     * Resets the stream x machine.
     */
    protected void reset() {
<span class="fc" id="L381">        fsm.reset();</span>
<span class="fc" id="L382">        printInfo(&quot;Machine has been reset.&quot;);</span>
<span class="fc" id="L383">        printSeparator(&quot;-&quot;);</span>
<span class="fc" id="L384">    }</span>
    
    protected SXM getFsm() {
<span class="fc" id="L387">        return fsm;</span>
    }
    
    protected void setFsm(SXM fsm) {
<span class="nc" id="L391">        this.fsm = fsm;</span>
<span class="nc" id="L392">    }</span>
    
    /**
     * Prints the separator.
     * 
     * @param c
     *            the c
     */
    protected abstract void printSeparator(String c);
    
    /**
     * Interactive animation.
     * 
     * @param className
     *            the class name
     * @param animationDirectory
     *            the animation directory
     * @param specificationDirectory
     *            the specification directory
     * @throws UnsupportedEncodingException
     */
    public abstract void interactiveAnimation(String className, String animationDirectory, String specificationDirectory)
            throws UnsupportedEncodingException;
    
    /**
     * Prints the info.
     * 
     * @param message
     *            the message
     */
    protected abstract void printInfo(String message);
    
    /**
     * Prints the error.
     * 
     * @param message
     *            the message
     */
    protected abstract void printError(String message);
    
    protected abstract void printError(String message,Object obj);
    
    /**
     * Alphabet print.
     */
    protected abstract void alphabetPrint();
    
    /**
     * Help.
     */
    protected abstract void help();
    
    /**
     * Animation options.
     * 
     * @param bufferedReader
     *            the buffered reader
     * @param rootElement
     *            the root element
     * @param doc
     *            the doc
     * @param className
     *            the class name
     * @param animationDirectory
     *            the animation directory
     * @param xmlOutput
     *            the xml output
     */
    protected abstract void animationOptions(Element rootElement, Document doc, String className,
            String animationDirectory, XMLOutputter xmlOutput);
    
    /**
     * Gets the fsm current output.
     * 
     * @return the fsmCurrentOutput
     */
    public Output getFsmCurrentOutput() {
<span class="fc" id="L469">        return fsmCurrentOutput;</span>
    }
    
    /**
     * Sets the fsm current output.
     * 
     * @param fsmCurrentOutput
     *            the fsmCurrentOutput to set
     */
    public void setFsmCurrentOutput(Output fsmCurrentOutput) {
<span class="nc" id="L479">        this.fsmCurrentOutput = fsmCurrentOutput;</span>
<span class="nc" id="L480">    }</span>

    /**
     * @return the txtInput
     */
    public boolean isTxtInput() {
<span class="nc" id="L486">        return txtInput;</span>
    }

    /**
     * @param txtInput the txtInput to set
     */
    public void setTxtInput(boolean txtInput) {
<span class="fc" id="L493">        this.txtInput = txtInput;</span>
<span class="fc" id="L494">    }</span>
    
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.3.201306030806</span></div></body></html>