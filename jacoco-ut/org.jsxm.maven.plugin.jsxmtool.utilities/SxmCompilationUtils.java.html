<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>SxmCompilationUtils.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">jsxm-maven-plugin</a> &gt; <a href="index.html" class="el_package">org.jsxm.maven.plugin.jsxmtool.utilities</a> &gt; <span class="el_source">SxmCompilationUtils.java</span></div><h1>SxmCompilationUtils.java</h1><pre class="source lang-java linenums">/**
 * JSXM Maven PLugin CONFIDENTIAL
 * 
 *  __________________
 * 
 * Unpublished Copyright Â© 2012-2013 Konstantinos Margaritis, 
 * All Rights Reserved.
 * 
 * NOTICE:  All information contained herein is, and remains the property of Konstantinos Margaritis . 
 *
 * The intellectual and technical concepts contained herein are proprietary to the owner
 * Konstantinos Margaritis and may be covered by U.S and Foreign Patents, patents in process, 
 * and are protected by trade secret or copyright law. Dissemination of this information or 
 * reproduction of this material is strictly forbidden unless prior written permission is
 * obtained from Konstantinos Margaritis. Access to the source code contained herein is hereby 
 * forbidden to anyone except the owner.Confidentiality and Non-disclosure agreements 
 * explicitly covering such access.
 *
 * The copyright notice above does not evidence any actual or intended publication 
 * or disclosure  of  this source code, which includes information that is confidential 
 * and/or proprietary, and is a trade secret, of  Konstantinos Margaritis. ANY REPRODUCTION, 
 * MODIFICATION, DISTRIBUTION, PUBLIC  PERFORMANCE, OR PUBLIC DISPLAY OF OR THROUGH USE  OF 
 * THIS  SOURCE CODE  WITHOUT  THE EXPRESS WRITTEN CONSENT OF Konstantinos Margaritis IS STRICTLY PROHIBITED, 
 * AND IN VIOLATION OF APPLICABLE LAWS AND INTERNATIONAL TREATIES.  THE RECEIPT OR POSSESSION OF  
 * THIS SOURCE CODE AND/OR RELATED INFORMATION DOES NOT CONVEY OR IMPLY ANY RIGHTS  
 * TO REPRODUCE, DISCLOSE OR DISTRIBUTE ITS CONTENTS, OR TO MANUFACTURE, USE, OR SELL 
 * ANYTHING THAT IT  MAY DESCRIBE, IN WHOLE OR IN PART.  
 * 
 */
package org.jsxm.maven.plugin.jsxmtool.utilities;

import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.LinkedList;
import java.util.List;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import javax.tools.Diagnostic;
import javax.tools.DiagnosticCollector;
import javax.tools.JavaCompiler;
import javax.tools.JavaFileObject;
import javax.tools.StandardJavaFileManager;
import javax.tools.ToolProvider;

import org.jsxm.jsxmcore.util.Various;
import org.jsxm.maven.plugin.jsxmtool.core.JSXM;
import org.jsxm.maven.plugin.jsxmtool.core.Specification;
import org.jsxm.maven.plugin.jsxmtool.runtimeexceptions.JsxmSpecificationParentException;
import org.jsxm.maven.plugin.jsxmtool.runtimeexceptions.MisplacedJsxmSpecificationException;
import org.xml.sax.InputSource;

import com.sun.codemodel.JCodeModel;
import com.sun.tools.xjc.api.S2JJAXBModel;
import com.sun.tools.xjc.api.SchemaCompiler;
import com.sun.tools.xjc.api.XJC;

/**
 * @author Konstantinos Margaritis
 * 
 */
public final class SxmCompilationUtils {
    
<span class="nc" id="L68">    private SxmCompilationUtils() {</span>
<span class="nc" id="L69">    }</span>
    
    /**
     * Given an array of names containing the absolute path, creates a list of
     * files in order to be provided in the compileListOfFiles.
     * 
     * @param names
     *            the names
     * @return the list
     */
    public static List&lt;File&gt; createCompilationList(final List&lt;String&gt; names) {
<span class="fc" id="L80">        final List&lt;File&gt; sourceFileList = new LinkedList&lt;File&gt;();</span>
<span class="fc bfc" id="L81" title="All 2 branches covered.">        for (int i = 0; i &lt; names.size(); i++) {</span>
<span class="fc" id="L82">            final String sourceFile = names.get(i);</span>
<span class="fc" id="L83">            sourceFileList.add(new File(sourceFile));</span>
        }
<span class="fc" id="L85">        return sourceFileList;</span>
    }
    
    /**
     * Given an array of names (without path) and providing the path through
     * directoryForCompilation creates a list of files with full paths in order
     * to be provided in the compileListOfFiles.
     * 
     * @param names
     *            the names
     * @param directoryForCompilation
     *            the directory for compilation
     * @return the list
     */
    public static List&lt;File&gt; createCompilationListWithPath(final String[] names, final String directoryForCompilation) {
<span class="fc" id="L100">        final List&lt;File&gt; sourceFileList = new ArrayList&lt;File&gt;();</span>
<span class="fc bfc" id="L101" title="All 2 branches covered.">        for (int i = 0; i &lt; names.length; i++) {</span>
<span class="fc" id="L102">            final String sourceFile = directoryForCompilation + JSXMUtils.FILE_SEPARATOR + names[i];</span>
<span class="fc" id="L103">            sourceFileList.add(new File(sourceFile));</span>
        }
<span class="fc" id="L105">        return sourceFileList;</span>
    }
    
    /**
     * Given a list of files and a destination path compiles all the files in
     * that list and places the compiled classes in the destination path.
     * 
     * @param sourceFileList
     *            the source file list
     * @param destinationPath
     *            the destination path
     */
    public static void compileListOfFiles(final List&lt;File&gt; sourceFileList, final String destinationPath) {
<span class="fc" id="L118">        final JavaCompiler compiler = ToolProvider.getSystemJavaCompiler();</span>
<span class="fc" id="L119">        final StandardJavaFileManager fileManager = compiler.getStandardFileManager(null, null, null);</span>
<span class="fc" id="L120">        final Iterable&lt;? extends JavaFileObject&gt; compilationUnits = fileManager.getJavaFileObjectsFromFiles(sourceFileList);</span>
<span class="fc" id="L121">        final List&lt;String&gt; optionList = new ArrayList&lt;String&gt;();</span>
<span class="fc" id="L122">        optionList.addAll(Arrays.asList(&quot;-d&quot;, destinationPath));</span>
<span class="fc" id="L123">        DiagnosticCollector&lt;JavaFileObject&gt; diagnostics = new DiagnosticCollector&lt;JavaFileObject&gt;();</span>
<span class="fc" id="L124">        final JavaCompiler.CompilationTask task = compiler.getTask(null, null, diagnostics, optionList, null, compilationUnits);</span>
<span class="fc" id="L125">        boolean status = task.call();</span>
<span class="fc bfc" id="L126" title="All 2 branches covered.">        if (!status) {</span>
<span class="fc bfc" id="L127" title="All 2 branches covered.">            for (Diagnostic&lt;?&gt; diagnostic : diagnostics.getDiagnostics()) {                </span>
<span class="fc" id="L128">                JSXM.getInstance().addDiagnostic(diagnostic);</span>
<span class="fc" id="L129">            }</span>
        }          
<span class="fc" id="L131">    }</span>
    
    /**
     * Used for compiling a whole directory. Given the directoryForCompilation,
     * compiles all the classes in that directory and places the compiled
     * classes in the destination path.
     * 
     * @param directoryForCompilation
     *            the directory for compilation
     * @param destinationPath
     *            the destination path
     */
    public static void compileDirectory(final String directoryForCompilation, final String destinationPath) {
<span class="fc" id="L144">        final List&lt;File&gt; sourceFileList = new ArrayList&lt;File&gt;();</span>
<span class="fc" id="L145">        final File compiledDirectory = new File(directoryForCompilation);</span>
<span class="fc" id="L146">        final File[] allFiles = compiledDirectory.listFiles();</span>
<span class="fc bfc" id="L147" title="All 2 branches covered.">        for (File file : allFiles) {</span>
<span class="pc bpc" id="L148" title="1 of 2 branches missed.">            if (file.getName().endsWith(&quot;.java&quot;)) {</span>
<span class="fc" id="L149">                final String sourceFile = directoryForCompilation + file.getName();</span>
<span class="fc" id="L150">                sourceFileList.add(new File(sourceFile));</span>
<span class="fc" id="L151">                JSXMUtils.LOGGER.debug(file.getName());</span>
            }
        }
<span class="pc bpc" id="L154" title="1 of 2 branches missed.">        if (!sourceFileList.isEmpty()) {</span>
<span class="fc" id="L155">            JSXMUtils.LOGGER.info(&quot;Compiling generated java files....: \n&quot;);</span>
<span class="fc" id="L156">            compileListOfFiles(sourceFileList, destinationPath);</span>
        } else {
<span class="nc" id="L158">            JSXMUtils.LOGGER.info(&quot;Not available &quot;);</span>
        }
<span class="fc" id="L160">    }</span>
        
    /**
     * Generates .java files from XSD files. The method searches in the whole
     * directory for XSD schema files and in case it finds a schema file it
     * generates all the .java files that are contained in the found schemas.
     * 
     * @param parentDirectory
     *            the parent directory
     * @param xjcDirectory
     *            the xjc directory
     * @param javaDirectory
     *            the java directory
     * @return true, if successful
     * @throws IOException
     *             Signals that an I/O exception has occurred.
     */
    public static boolean generatJavaFromXSD(String parentDirectory, String xjcDirectory, String javaDirectory)
            throws IOException {
<span class="fc" id="L179">        final String directoryForCompilation = parentDirectory;</span>
<span class="fc" id="L180">        final String destinationPath = xjcDirectory;</span>
<span class="fc" id="L181">        final List&lt;File&gt; sourceFileList = new ArrayList&lt;File&gt;();</span>
<span class="fc" id="L182">        final File compiledDirectory = new File(directoryForCompilation);</span>
<span class="fc" id="L183">        final File[] allFiles = compiledDirectory.listFiles();</span>
<span class="fc" id="L184">        boolean compileGenerated = false;</span>
<span class="fc" id="L185">        boolean flag = true;</span>
<span class="fc bfc" id="L186" title="All 2 branches covered.">        for (File file : allFiles) {</span>
<span class="fc bfc" id="L187" title="All 2 branches covered.">            if (file.getName().endsWith(&quot;.xsd&quot;)) {</span>
<span class="pc bpc" id="L188" title="1 of 2 branches missed.">                if (flag) {</span>
<span class="fc" id="L189">                    JSXMUtils.LOGGER.info(&quot;\nThe XSD file is located in the :&quot; + directoryForCompilation</span>
                            + &quot;\n and the generated files will be placed in the &quot; + destinationPath);
<span class="fc" id="L191">                    flag = false;</span>
                }
<span class="fc" id="L193">                JSXMUtils.LOGGER.info(&quot;##############################################################&quot;);</span>
<span class="fc" id="L194">                JSXMUtils.LOGGER.info(&quot;#Generating java files from XSD ---&gt; &quot; + file.getName() + &quot; #&quot;);</span>
<span class="fc" id="L195">                JSXMUtils.LOGGER.info(&quot;##############################################################&quot;);</span>
<span class="fc" id="L196">                final String sourceFile = directoryForCompilation + JSXMUtils.FILE_SEPARATOR + file.getName();</span>
<span class="fc" id="L197">                sourceFileList.add(new File(sourceFile));</span>
<span class="fc" id="L198">                final SchemaCompiler sc = XJC.createSchemaCompiler();</span>
                
<span class="fc" id="L200">                final File schemaFile = new File(sourceFile);</span>
<span class="fc" id="L201">                final InputSource is = new InputSource(new FileInputStream(schemaFile));</span>
<span class="pc bpc" id="L202" title="1 of 2 branches missed.">                if (!JSXMUtils.FILE_SEPARATOR.equals(&quot;/&quot;)) {</span>
<span class="nc" id="L203">                    is.setSystemId(schemaFile.toURI().toString());</span>
                } else {
<span class="fc" id="L205">                    is.setSystemId(schemaFile.getAbsolutePath());</span>
                }
<span class="fc" id="L207">                sc.parseSchema(is);</span>
<span class="fc" id="L208">                final S2JJAXBModel model = sc.bind();</span>
<span class="fc" id="L209">                final JCodeModel jCodeModel = model.generateCode(null, null);</span>
<span class="fc" id="L210">                SysStreamsLogger.bindSystemStreams();</span>
                /*
                 * The reason for this bind is to redirect system.out of build
                 * method to log file
                 */
                // TODO Give different destination path for each specification
                // and additionally provide
                // TODO different folder for each XSD. Using this way the
                // generated java files will have their own
                // TODO Object factory and it will not be overwritten from other
                // java files(generated from XSD).
                // TODO Proposed structure
                // target/temp/xjc/generated/specName/xsdName/generated/**.java
<span class="fc" id="L223">                jCodeModel.build(new File(destinationPath));</span>
<span class="fc" id="L224">                System.setOut(System.out);</span>
<span class="fc" id="L225">                SysStreamsLogger.unbindSystemStreams();</span>
                /*
                 * The reason for this unbind is to redirect system.out to
                 * console.
                 */
                /*
                 * new Build was used in order save java files in the src
                 * directory. The javaDirectory was used. See revision 548.
                 */
<span class="fc" id="L234">                JSXMUtils.LOGGER.info(&quot;##############################################################&quot;);</span>
<span class="fc" id="L235">                compileGenerated = true;</span>
            }
        }
<span class="fc" id="L238">        return compileGenerated;</span>
    }
    
    /**
     * Given a name with extension it removes the extension and the dot. For
     * example Test.xml will be Test ---&gt;.xml will be removed. The lenght of the
     * extension includes also the dot. For example .class is lenght of 6.
     * 
     * @param name
     *            the name
     * @param extensionLength
     *            the extension length
     * @return the string
     */
    public static String extractSourceClass(String name, int extensionLength) {
<span class="fc" id="L253">        StringBuffer extensionBuffer = new StringBuffer();</span>
<span class="fc bfc" id="L254" title="All 2 branches covered.">        for (int i = 0; i &lt; extensionLength; i++) {</span>
<span class="fc" id="L255">            extensionBuffer.append(&quot;.&quot;);</span>
        }
<span class="fc" id="L257">        String extension = extensionBuffer.toString();</span>
<span class="fc" id="L258">        final String reverse = new StringBuffer(name).reverse().toString();</span>
<span class="fc" id="L259">        final Pattern pattern = Pattern.compile(&quot;(?&lt;=&quot; + extension + &quot;).*.(?=)&quot;);</span>
<span class="fc" id="L260">        final Matcher matcher = pattern.matcher(reverse);</span>
<span class="fc" id="L261">        matcher.find();</span>
<span class="fc" id="L262">        JSXMUtils.LOGGER.debug(new StringBuffer(matcher.group()).reverse().toString());</span>
<span class="fc" id="L263">        return new StringBuffer(matcher.group()).reverse().toString();</span>
    }
    
    /**
     * Extract package.
     * 
     * @param name
     *            the name
     * @param absolutePath
     *            the absolute path
     * @return the string
     */
    public static String extractPackage(String name, String absolutePath) {
<span class="fc" id="L276">        Pattern p = Pattern.compile(&quot;(?&lt;=&quot; + &quot;\\&quot; + &quot;bjava&quot; + Pattern.quote(File.separator) + &quot;\\&quot; + &quot;b).*?(?=&quot; + &quot;\\&quot;</span>
                + &quot;b&quot; + Pattern.quote(File.separator) + name + &quot;\\&quot; + &quot;b)&quot;);
<span class="fc" id="L278">        Matcher m = p.matcher(absolutePath);</span>
<span class="fc" id="L279">        m.find();</span>
<span class="fc" id="L280">        JSXMUtils.LOGGER.debug(name);</span>
<span class="fc" id="L281">        JSXMUtils.LOGGER.debug(absolutePath);</span>
<span class="fc" id="L282">        JSXMUtils.LOGGER.debug(m.group());</span>
<span class="fc" id="L283">        return m.group();</span>
    }
    
    /**
     * Creates the spec name folder list.
     * 
     * @param packagesList
     *            the packages list
     * @param specificationFolderList
     *            the specification folder list
     */
    public static void createSpecNameFolderList(List&lt;File&gt; packagesList, List&lt;File&gt; specificationFolderList) {
<span class="fc bfc" id="L295" title="All 2 branches covered.">        for (File file : packagesList) {</span>
            /*
             * specification folder
             */
<span class="fc" id="L299">            File parent = new File(file.getParent());</span>
            /*
             * parent of specification
             */
<span class="fc" id="L303">            File grandParent = new File(parent.getParent());</span>
<span class="fc" id="L304">            JSXMUtils.LOGGER.debug(&quot;Checking : &quot; + parent.getName() + &quot; folder from &quot; + grandParent.getName()</span>
                    + &quot; root directory&quot;);
            
<span class="pc bpc" id="L307" title="1 of 2 branches missed.">            if (!file.isDirectory()) {</span>
<span class="fc bfc" id="L308" title="All 2 branches covered.">                if (parent.getName().equals(&quot;specification&quot;)) {</span>
<span class="fc bfc" id="L309" title="All 2 branches covered.">                    if (grandParent.getName().equals(</span>
                            extractSourceClass(file.getName(), JSXM.SPECIFICATION_EXTENSION_LENGTH))) {
<span class="fc" id="L311">                        specificationFolderList.add(file);</span>
<span class="fc" id="L312">                        JSXMUtils.LOGGER.info(&quot;  ---&gt; &quot; + grandParent.getName());</span>
<span class="fc" id="L313">                        JSXMUtils.LOGGER.debug(&quot;  ---&gt; &quot; + file.getName());</span>
                    } else {
<span class="fc" id="L315">                        JSXMUtils.LOGGER.error(&quot;Jsxm model name does not comply with the parent folder.&quot;);</span>
<span class="fc" id="L316">                        JSXMUtils.LOGGER.error(&quot;Jsxm model name must be the same as the root folder.&quot;);</span>
<span class="fc" id="L317">                        JSXMUtils.LOGGER.error(&quot;Current root folder: --&gt; &quot; + grandParent.getName());</span>
<span class="fc" id="L318">                        JSXMUtils.LOGGER.error(&quot;For example &quot; + file.getName() + &quot; should be be placed under &quot; + &quot;&quot;</span>
                                + extractSourceClass(file.getName(), JSXM.SPECIFICATION_EXTENSION_LENGTH)
                                + &quot;/specification/ directory or vise versa.&quot;);
<span class="fc" id="L321">                        throw new JsxmSpecificationParentException(</span>
                                &quot;\nJsxm model name does not comply with the parent folder.\n&quot;);
                    }
                } else {
<span class="fc" id="L325">                    JSXMUtils.LOGGER.error(&quot;Jsxm model is placed in wrong folder. Place jsxm model &quot;</span>
                            + file.getName() + &quot; under specification folder&quot;);
<span class="fc" id="L327">                    throw new MisplacedJsxmSpecificationException(</span>
                            &quot;\nJsxm model is placed in wrong folder. Place jsxm model &quot; + file.getName()
                                    + &quot; under specification folder&quot;);
                }
            }
<span class="fc" id="L332">        }</span>
<span class="fc" id="L333">    }</span>
    
    /**
     * Check jsxm java tests.
     * 
     * @param specificationFolderList
     *            the specification folder list
     * @param testDirectory
     *            the test directory
     */
    public static void checkJsxmJavaTests(List&lt;File&gt; specificationFolderList, String testDirectory) {
<span class="fc bfc" id="L344" title="All 2 branches covered.">        for (int i = 0; i &lt; specificationFolderList.size(); i++) {</span>
<span class="fc" id="L345">            List&lt;File&gt; jsxmTestsList = new LinkedList&lt;File&gt;();</span>
<span class="fc" id="L346">            SxmFileUtils.traverseDirectory(new File(testDirectory), jsxmTestsList, specificationFolderList.get(i)</span>
                    .getName() + &quot;JsxmAdapterTest.java&quot;);
<span class="fc" id="L348">            File tempSpec = new File(specificationFolderList.get(i) + JSXMUtils.FILE_SEPARATOR + &quot;specification&quot;</span>
                    + JSXMUtils.FILE_SEPARATOR + specificationFolderList.get(i).getName() + &quot;.xml&quot;);
            
<span class="fc" id="L351">            SimpleDateFormat sdf = new SimpleDateFormat(&quot;MM/dd/yyyy HH:mm:ss&quot;);</span>
<span class="pc bpc" id="L352" title="3 of 4 branches missed.">            if (!jsxmTestsList.isEmpty() &amp;&amp; jsxmTestsList.get(0).exists()) {</span>
<span class="nc" id="L353">                JSXMUtils.LOGGER.debug(jsxmTestsList.get(0).getName() + &quot; exists.&quot;);</span>
                
<span class="nc" id="L355">                JSXMUtils.LOGGER.debug(tempSpec.getAbsolutePath() + &quot; was last modified in :&quot;</span>
                        + sdf.format(tempSpec.lastModified()));
<span class="nc" id="L357">                JSXMUtils.LOGGER.debug(jsxmTestsList.get(0).getAbsolutePath() + &quot; was last modified in :&quot;</span>
                        + sdf.format(jsxmTestsList.get(0).lastModified()));
                
<span class="nc bnc" id="L360" title="All 2 branches missed.">                if (tempSpec.lastModified() &gt; jsxmTestsList.get(0).lastModified()) {</span>
<span class="nc" id="L361">                    JSXMUtils.LOGGER.info(&quot;Deleting  &quot; + jsxmTestsList.get(0));</span>
<span class="nc bnc" id="L362" title="All 2 branches missed.">                    if(jsxmTestsList.get(0).delete()){</span>
<span class="nc" id="L363">                        JSXMUtils.LOGGER.debug(&quot;File has been deleted&quot;);</span>
                    }
                }
                
            }
        }
<span class="fc" id="L369">    }</span>
    
    /**
     * Sets the class loader directories.
     * 
     * @param tempTarget
     *            the new class loader directories
     */
    public static void setClassLoaderDirectories(String tempTarget) {
<span class="fc" id="L378">        List&lt;String&gt; urlDirectoriesLoad = new LinkedList&lt;String&gt;();</span>
<span class="fc" id="L379">        urlDirectoriesLoad.add(tempTarget + JSXMUtils.FILE_SEPARATOR + &quot;temp&quot; + JSXMUtils.FILE_SEPARATOR);</span>
<span class="fc" id="L380">        JSXMUtils.LOGGER.debug(&quot;URLClassLoader path&quot; + &quot;  ---&gt; &quot; + tempTarget + JSXMUtils.FILE_SEPARATOR</span>
                + &quot;temp&quot; + JSXMUtils.FILE_SEPARATOR);
<span class="fc" id="L382">        Various.getInstance().setUrlDirectoriesLoad(urlDirectoriesLoad);</span>
<span class="fc" id="L383">    }</span>
    
    /**
     * Sets the implementation package.
     * 
     * @param javaFiles
     *            the java files
     * @param p
     *            the p
     * @param tempSpec
     *            the temp spec
     */
    public static void setImplementationPackage(List&lt;File&gt; javaFiles, Specification p, File tempSpec) {
<span class="fc bfc" id="L396" title="All 2 branches covered.">        for (int k = 0; k &lt; javaFiles.size(); k++) {</span>
<span class="fc bfc" id="L397" title="All 2 branches covered.">            if (javaFiles.get(k).getName()</span>
                    .equals(extractSourceClass(tempSpec.getName(), JSXM.SPECIFICATION_EXTENSION_LENGTH) + &quot;.java&quot;)) {
<span class="fc" id="L399">                p.setJavaImplementation(javaFiles.get(k).getAbsoluteFile());</span>
<span class="fc" id="L400">                p.setPackageTest(extractPackage(javaFiles.get(k).getName(), javaFiles.get(k).getAbsoluteFile()</span>
                        .toString()));
<span class="fc" id="L402">                JSXMUtils.LOGGER.debug(&quot;Java Implementation : &quot; + javaFiles.get(k).getAbsoluteFile());</span>
<span class="fc" id="L403">                JSXMUtils.LOGGER.debug(&quot;Package : &quot;</span>
                        + extractPackage(javaFiles.get(k).getName(), javaFiles.get(k).getAbsoluteFile().toString()));
<span class="fc" id="L405">                JSXMUtils.LOGGER.debug(&quot;Specification match implementation&quot;);</span>
            }
        }
        
<span class="fc" id="L409">    }</span>
    
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.3.201306030806</span></div></body></html>